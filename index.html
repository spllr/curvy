<!DOCTYPE html>
<html>
<head>
  <title>Berry Pie Curves</title>
  <meta id="viewport" name="viewport" content ="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="Author" content="Klaas Speller, over at @StoneSoupGr">

  <style type="text/css">

    body * {
      margin: 0;
      padding: 0;
      font-weight: normal;
    }

    html, body {
      margin: 0;
      padding: 0;
      background-color: #34001F;
      font-family: "Helvetica Neue", Helvetica, Arial, Sans-Serif;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .curve-control {
      background-color: #FF0;
      height: 62%;
      min-height: 150px;
      position: relative;
    }

    .curve-control header {
      line-height: 64px;
      text-align: center;
    }

    .curve-control .preview {
      background-color: #333;
      width: 100%;
      height: 90%;
    }

    .curve-control .curve { 
      -webkit-user-select: none;
    }

    .indicator {
      background-color: #FFF;
      width: 50px;
      height: 50px;
      border-radius: 25px;
      display: inline-block;
      -webkit-tranform: translate(-150%, 0);
      margin-left: 5px;
      margin-right: 5px;
      margin-top: 10px;
      margin-bottom: 10px;
      display: none;
      -webkit-transition: background-color 0.25s linear;
      -webkit-user-select: none;
    }

    .indicator.active {
      display: inline-block;
      background-color: #645B99;
    }

    .indicator.current {
      background-color: #FFF;
    }

    .indicator.current .proof {
      background-color: #F00;
    }

    .proof {
      background-color: #FFF;
      width: 80%;
      height: 80%;
      border-radius: 100%;
      margin: 10% 0 0 10%;
      -webkit-user-select: none;
    }

    .proof.pause {
      background-color: #FF0;
    }

    .tracked-curves {
      display: block;
      position: relative;
      background-color: #8D0054;
      height: 30%;
      text-align: center;
      overflow-x: hidden;
      overflow-y: scroll;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 10px;
    }

    footer {
      color: #DBC6DC;
      text-align: center;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: antialiased;
      height: 10%;
      padding-top: 2%;
      font-size: 12px;
    }

    footer a, footer a:link, footer a:active, footer a:visited {
     color: #DBC6DC;
     -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: antialiased;
    }

  </style>
</head>
<body>




  <article class="curve-control">
    <header>
      <h1>Control The Curve</h1>
    </header>
    <section class="preview">
      <canvas class="curve" width="100" height="100">
      </canvas>
    </section>
    <nav class="tracked-curves">
      <section class="indicator curve-animation">
        <div class="proof">

        </div>
      </section>
    </nav>
    <style type="text/css" id="style">
      @-webkit-keyframes curve-animation {}
    </style>
    <footer>
      By <a href="http://about.spllr.net" title="Klaas Speller">spllr</a> over at <a href="http://stonesoup.io" title="Stone Soup">Stone Soup</a>
    </footer>
  </article>




  <script>


    var CurveControl = function() {
      var allAnimations = {}

      // Our data stuff
      var animating = false,
          curveHeight,
          curveWidth,
          decay = false,
          endTime,
          firstVector,
          lastVector,
          relativeTrackedCurveVectors = [],
          startTime,
          time = 0,
          timeDecayPerTick = 0,
          totalTime = 0,
          trackedCurveVectors = [],
          trackingUserDrawingCurve = false

      // Event types
      var startTrackingEventName = isTouch() ? "touchstart" : "mousedown",
          endTrackingEventName = isTouch() ? "touchend" : "mouseup",
          trackingEventName = isTouch() ? "touchmove" : "mousemove"

      // Our stage
      var stage = document.querySelector(".curve-control")
          canvas = stage.querySelector(".curve"),
          context = canvas.getContext("2d"),
          proof = stage.querySelector(".proof"),
          trackedCurves = stage.querySelector(".tracked-curves"),
          currentIndicator = null
      

      trackedCurves.addEventListener("click", function(event) {
        event.preventDefault()
        var animationName = event.target.dataset.animationName
        if (!animationName)
          return

        trackedCurveVectors = allAnimations[animationName].absolute || []
        relativeTrackedCurveVectors = allAnimations[animationName].relative || []

        disableCurrentIndicators()

        var indicator = stage.querySelector(".indicator[data-animation-name=" + animationName + "]")
        indicator.classList.add("current")
      })

      canvas.addEventListener("touchmove", function(event) {
          event.preventDefault()
      }, false)

      // Canvas wants explicit size for pretty rendering
      var fitCanvas = function() {
        canvas.width = curveWidth = canvas.parentNode.clientWidth
        canvas.height = curveHeight = canvas.parentNode.clientHeight  
      }
      fitCanvas()
      window.addEventListener("resize", fitCanvas)

      stage.addEventListener("scroll", function(event) {
        event.preventDefault()
      })

      proof.addEventListener("click", function() {
        if (proof.style.webkitAnimationPlayState !== "paused") {
          proof.style.webkitAnimationPlayState =  "paused"
          proof.classList.add("pause")
        } else {
          proof.style.webkitAnimationPlayState =  "running"
          proof.classList.remove("pause")
        }
      })

      // Capture proof animation start
      proof.addEventListener("webkitAnimationStart", function(event) {
        console.log("start animate", event)
      }, false)

      // Capture proof animation end
      proof.addEventListener("webkitAnimationEnd", function(event) {
        console.log("end animate", event)
      }, false)

      // Capture proof animation iteration
      proof.addEventListener("webkitAnimationIteration", function(event) {
        console.log("iterate animate", event)
      }, false)

      // Start tracking of the curve
      var beginTrackingOfUserDrawingCurve = function(event) {
        startTime = new Date().getTime()
        trackedCurveVectors = []
        relativeTrackedCurveVectors = []
        trackingUserDrawingCurve = true
      }
      canvas.addEventListener(startTrackingEventName, beginTrackingOfUserDrawingCurve)
      // canvas.addEventListener("mousedown", beginTrackingOfUserDrawingCurve)


      // End tracking of the curve
      var endTrackingOfUserDrawingCurve = function(event) {
        endTime = new Date().getTime()
        totalTime = endTime - startTime
        trackingUserDrawingCurve = false
        decay = false

        var startVector = trackedCurveVectors[0],
            endVector = trackedCurveVectors[trackedCurveVectors.length - 1]
        
        if (!endVector || !startVector)
          return
        
        relativeTrackedCurveVectors = []
        fullWitdh = endVector.x - startVector.x,
        fullHeight = curveHeight

        for (var i = 0; i < trackedCurveVectors.length; i++) {
          var absoluteVector = trackedCurveVectors[i],
              relativeVector = {}

          relativeVector.x = (absoluteVector.x - startVector.x) / fullWitdh
          relativeVector.y = 1 - absoluteVector.y / fullHeight
          relativeTrackedCurveVectors.push(relativeVector)
        }

        var generatedAnimationName = generateCSSAnimationStyles(document.styleSheets[1]),
            indicatorTemplate = stage.querySelector(".indicator:last-child"),
            indicator = indicatorTemplate.cloneNode(true),
            proof = indicator.querySelector(".proof")


        allAnimations[generatedAnimationName] = {
          absolute: trackedCurveVectors,
          relative: relativeTrackedCurveVectors
        }

        disableCurrentIndicators()

        indicator.classList.add("active")
        indicator.classList.add("current")
        currentIndicator = indicator
        
        indicator.dataset.animationName = generatedAnimationName
        proof.dataset.animationName = generatedAnimationName
        proof.style.webkitAnimationName = ""
        proof.style.webkitAnimationPlayState = "paused"

        indicatorTemplate.parentNode.insertBefore(indicator, indicatorTemplate.parentNode.firstChild)

        setTimeout(function() {
          proof.classList.add(generatedAnimationName)
          proof.style.webkitAnimationDuration =  totalTime + "ms"
          proof.style.webkitAnimationPlayState =  "running"
          proof.style.webkitAnimationName =  generatedAnimationName
          proof.style.webkitAnimationIterationCount = "infinite"
        }, 0)

        firstVector = null
        lastVector = null
      }
      canvas.addEventListener(endTrackingEventName, endTrackingOfUserDrawingCurve)


      // Track the user drawing a curve
      var trackUserDrawingCurve = function(event) {
        if (!trackingUserDrawingCurve)
          return

        var vector
        if (event.targetTouches) {
          vector = { x: event.targetTouches[0].pageX, y: event.targetTouches[0].pageY }
          vector.y -= 64
        } else {
          vector = { x: event.offsetX, y: event.offsetY }
        }

        if (lastVector && lastVector.x > vector.x)
          vector.x = lastVector.x

        trackedCurveVectors.push(vector)
        lastVector = vector
        
        if (trackedCurveVectors.length === 1) {
          firstVector = vector
          time = 0
          decay = true
        }

        tick() // Render
      }
      canvas.addEventListener(trackingEventName, trackUserDrawingCurve)


      // Generate the CSS animation string
      var curveAnimationIterationCount = 0
      var generateCSSAnimationStyles = function(parentStyleSheet) {
        curveAnimationIterationCount++
        var name = "curve-animation-" + curveAnimationIterationCount
            css = "@-webkit-keyframes " + (name || "curve-animation") + " {\n"
        for (var i = 0; i < relativeTrackedCurveVectors.length; i++) {
          var relativeVector = relativeTrackedCurveVectors[i]
          css += (relativeVector.x * 100) + "% { opacity: " + relativeVector.y + ";\n"
          css += "-webkit-transform: scale(" + relativeVector.y +"); }\n";
        }
        css += "}"

        var cssClass = "." + name + " {\n"
        cssClass += "-webkit-animation: " + name + " " + totalTime + "s infinite;\n"
        cssClass += "}"
        
        setTimeout(function() {
          parentStyleSheet.insertRule(css, 0)
          parentStyleSheet.insertRule(cssClass, 0)
        }, 0)

        return name
      }


      // Find the css rules
      var getCSSRuleForAnimation = function(animationName) {
        var allStyleSheets = document.styleSheets
        for (var i = 0; i < allStyleSheets.length; i++) {
          var rules = allStyleSheets[i].cssRules
          for (var j = 0; j < rules.length; j++) {
            var rule = rules[j]
            console.log(rule.type)
            if (rule.type === window.CSSRule.WEBKIT_KEYFRAMES_RULE && rule.name === animationName) {
              return rule
            }
          }
        }
        return null
      }

      var disableCurrentIndicators = function() {
        var currents = stage.querySelectorAll(".current")
        for (var i = 0; i < currents.length; i++) {
          currents[i].classList.remove("current")
        }
      }


      // The animation loop tick
      var tick = function() {
        if (animating)
          window.requestAnimationFrame(tick)
        
        if (decay)
          time += timeDecayPerTick

        context.save()
        context.clearRect(0, 0, curveWidth, curveHeight)

        context.globalAlpha = 0.2
        context.strokeStyle = "#CEBF55"
        context.strokeWidth = 0.1
          
        // center line
        context.beginPath()
        context.moveTo(0, curveHeight / 2)
        context.lineTo(curveWidth, curveHeight / 2)
        context.closePath()
        context.stroke()

        // startline
        if (firstVector) {
          context.save()
          context.strokeStyle = "#CA96B8"
          context.globalAlpha = 0.5;
          context.beginPath()
          context.moveTo(firstVector.x, 0)
          context.lineTo(firstVector.x, curveHeight)
          context.closePath()
          context.stroke()
          context.restore()
        }

        context.fillStyle = "#FFFFFF"

        context.save()
        context.globalAlpha = 0.4;
        context.beginPath()
        for (var i = 0; i < trackedCurveVectors.length; i++) {
          var trackedVector = trackedCurveVectors[i],
              vector = {
            x: trackedVector.x,
            y: trackedVector.y
          }
          context.fillRect(vector.x - 1, vector.y - 1, 2, 2)
          context.lineTo(vector.x, vector.y)
        }
        context.globalAlpha = 0.3;
        context.stroke()
        context.closePath()
        context.restore()
        context.restore()
      }
      tick() // Start the animation loop
    }

  
    var curveControllers = {}
    window.addEventListener("DOMContentLoaded", function() {
      var curveControl = new CurveControl()
      curveControl.animate = false
    })

    // Are we on a touch device (e.g. iPad, iPhone, Android)
    var isTouch = function() {
      return ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch
    }

  </script>
</body>
</html>